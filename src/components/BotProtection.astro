---
// Bot Protection Component for GadgetFix
// Multi-layered protection against automated attacks
---

<script>
// Bot Protection System - Multi-layered Defense
(function() {
	'use strict';
	
	// Configuration
	const config = {
		enableHoneypot: true,
		enableTimeValidation: true,
		enableBehaviorTracking: true,
		enableFingerprinting: true,
		enableRateLimit: true,
		minFormTime: 3000, // Minimum 3 seconds to fill form
		maxRequestsPerMinute: 5,
		suspiciousBehaviorThreshold: 3
	};
	
	// Bot Detection State
	window.botDetection = {
		isBot: false,
		suspicionScore: 0,
		fingerprint: null,
		sessionId: null,
		interactions: {
			mouse: 0,
			keyboard: 0,
			touch: 0,
			focus: 0,
			scroll: 0
		},
		formLoadTimes: new Map(),
		requestCount: [],
		blockedReasons: []
	};
	
	// Generate session ID
	function generateSessionId() {
		return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
	}
	
	// Initialize session
	window.botDetection.sessionId = generateSessionId();
	
	// 1. ADVANCED BOT DETECTION
	
	// WebDriver Detection (Multiple Methods)
	function detectWebDriver() {
		const detectionMethods = [];
		
		// Method 1: Navigator webdriver
		if (navigator.webdriver === true) {
			detectionMethods.push('webdriver_flag');
		}
		
		// Method 2: Chrome DevTools Protocol
		const cdpDetected = (function() {
			let detected = false;
			const e = new Error();
			Object.defineProperty(e, 'stack', {
				get() {
					detected = true;
				}
			});
			console.debug(e);
			return detected;
		})();
		
		if (cdpDetected) {
			detectionMethods.push('cdp_detection');
		}
		
		// Method 3: Phantom/Headless Detection
		if (window.callPhantom || window._phantom || window.phantom) {
			detectionMethods.push('phantom_detected');
		}
		
		// Method 4: Puppeteer Detection
		if (window.chrome && !window.chrome.runtime) {
			detectionMethods.push('puppeteer_suspected');
		}
		
		// Method 5: Missing window properties
		const requiredProps = ['localStorage', 'sessionStorage', 'indexedDB'];
		for (const prop of requiredProps) {
			if (!(prop in window)) {
				detectionMethods.push(`missing_${prop}`);
			}
		}
		
		return detectionMethods;
	}
	
	// 2. DEVICE FINGERPRINTING
	
	function generateFingerprint() {
		const fingerprint = {
			screen: {
				width: screen.width,
				height: screen.height,
				depth: screen.colorDepth,
				pixelRatio: window.devicePixelRatio
			},
			timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
			language: navigator.language,
			platform: navigator.platform,
			hardwareConcurrency: navigator.hardwareConcurrency,
			deviceMemory: navigator.deviceMemory,
			touchSupport: 'ontouchstart' in window,
			webgl: getWebGLFingerprint(),
			canvas: getCanvasFingerprint(),
			fonts: getInstalledFonts(),
			audioContext: getAudioFingerprint()
		};
		
		// Create hash of fingerprint
		const fpString = JSON.stringify(fingerprint);
		let hash = 0;
		for (let i = 0; i < fpString.length; i++) {
			const char = fpString.charCodeAt(i);
			hash = ((hash << 5) - hash) + char;
			hash = hash & hash;
		}
		
		window.botDetection.fingerprint = Math.abs(hash).toString(36);
		return fingerprint;
	}
	
	// Canvas Fingerprinting
	function getCanvasFingerprint() {
		try {
			const canvas = document.createElement('canvas');
			const ctx = canvas.getContext('2d');
			canvas.width = 200;
			canvas.height = 50;
			
			// Draw test content
			ctx.textBaseline = 'top';
			ctx.font = '14px Arial';
			ctx.fillStyle = '#f60';
			ctx.fillRect(125, 1, 62, 20);
			ctx.fillStyle = '#069';
			ctx.fillText('BotDetection', 2, 15);
			ctx.fillStyle = 'rgba(102, 204, 0, 0.7)';
			ctx.fillText('Canvas FP', 4, 17);
			
			return canvas.toDataURL().slice(-50);
		} catch (e) {
			return 'canvas_blocked';
		}
	}
	
	// WebGL Fingerprinting
	function getWebGLFingerprint() {
		try {
			const canvas = document.createElement('canvas');
			const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
			if (!gl) return 'webgl_unsupported';
			
			const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
			if (debugInfo) {
				return {
					vendor: gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL),
					renderer: gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL)
				};
			}
			return 'debug_info_unavailable';
		} catch (e) {
			return 'webgl_blocked';
		}
	}
	
	// Audio Context Fingerprinting
	function getAudioFingerprint() {
		try {
			const AudioContext = window.AudioContext || window.webkitAudioContext;
			if (!AudioContext) return 'audio_unsupported';
			
			const context = new AudioContext();
			const oscillator = context.createOscillator();
			const analyser = context.createAnalyser();
			const gain = context.createGain();
			const scriptProcessor = context.createScriptProcessor(4096, 1, 1);
			
			gain.gain.value = 0;
			oscillator.connect(analyser);
			analyser.connect(scriptProcessor);
			scriptProcessor.connect(gain);
			gain.connect(context.destination);
			
			oscillator.start(0);
			
			return 'audio_' + context.sampleRate;
		} catch (e) {
			return 'audio_blocked';
		}
	}
	
	// Font Detection
	function getInstalledFonts() {
		const testFonts = ['Arial', 'Verdana', 'Times New Roman', 'Courier', 'Comic Sans MS'];
		const baseFonts = ['monospace', 'sans-serif', 'serif'];
		const testString = 'mmmmmmmmmmlli';
		const testSize = '72px';
		
		const canvas = document.createElement('canvas');
		const ctx = canvas.getContext('2d');
		
		const detectedFonts = [];
		for (const font of testFonts) {
			let fontDetected = false;
			for (const baseFont of baseFonts) {
				ctx.font = `${testSize} ${baseFont}`;
				const baseWidth = ctx.measureText(testString).width;
				
				ctx.font = `${testSize} '${font}', ${baseFont}`;
				const testWidth = ctx.measureText(testString).width;
				
				if (baseWidth !== testWidth) {
					fontDetected = true;
					break;
				}
			}
			if (fontDetected) detectedFonts.push(font);
		}
		
		return detectedFonts.length;
	}
	
	// 3. BEHAVIORAL ANALYSIS
	
	// Track human-like interactions
	function initBehaviorTracking() {
		// Mouse movement tracking
		let lastMouseTime = Date.now();
		let mouseVelocities = [];
		
		document.addEventListener('mousemove', function(e) {
			const currentTime = Date.now();
			const timeDiff = currentTime - lastMouseTime;
			
			if (timeDiff > 0) {
				const velocity = Math.sqrt(e.movementX ** 2 + e.movementY ** 2) / timeDiff;
				mouseVelocities.push(velocity);
				
				// Check for inhuman precision
				if (mouseVelocities.length > 10) {
					const avgVelocity = mouseVelocities.reduce((a, b) => a + b) / mouseVelocities.length;
					const variance = mouseVelocities.reduce((sum, v) => sum + Math.pow(v - avgVelocity, 2), 0) / mouseVelocities.length;
					
					// Bots often have very consistent velocity
					if (variance < 0.01) {
						window.botDetection.suspicionScore++;
						window.botDetection.blockedReasons.push('consistent_mouse_velocity');
					}
					
					mouseVelocities = mouseVelocities.slice(-10);
				}
			}
			
			lastMouseTime = currentTime;
			window.botDetection.interactions.mouse++;
		}, { passive: true });
		
		// Keyboard tracking
		let keyTimings = [];
		let lastKeyTime = 0;
		
		document.addEventListener('keydown', function(e) {
			const currentTime = Date.now();
			if (lastKeyTime > 0) {
				const timing = currentTime - lastKeyTime;
				keyTimings.push(timing);
				
				// Check for inhuman typing speed
				if (keyTimings.length > 5) {
					const avgTiming = keyTimings.reduce((a, b) => a + b) / keyTimings.length;
					
					// Suspiciously fast typing (< 50ms average)
					if (avgTiming < 50) {
						window.botDetection.suspicionScore++;
						window.botDetection.blockedReasons.push('superhuman_typing_speed');
					}
					
					// Suspiciously consistent timing
					const variance = keyTimings.reduce((sum, t) => sum + Math.pow(t - avgTiming, 2), 0) / keyTimings.length;
					if (variance < 10) {
						window.botDetection.suspicionScore++;
						window.botDetection.blockedReasons.push('robotic_typing_pattern');
					}
					
					keyTimings = keyTimings.slice(-10);
				}
			}
			lastKeyTime = currentTime;
			window.botDetection.interactions.keyboard++;
		}, { passive: true });
		
		// Touch events
		document.addEventListener('touchstart', function() {
			window.botDetection.interactions.touch++;
		}, { passive: true });
		
		// Focus events
		document.addEventListener('focus', function() {
			window.botDetection.interactions.focus++;
		}, true);
		
		// Scroll events
		let scrollCount = 0;
		let lastScrollTime = 0;
		
		document.addEventListener('scroll', function() {
			const currentTime = Date.now();
			
			// Check for rapid automated scrolling
			if (lastScrollTime > 0 && currentTime - lastScrollTime < 50) {
				scrollCount++;
				if (scrollCount > 10) {
					window.botDetection.suspicionScore++;
					window.botDetection.blockedReasons.push('automated_scrolling');
				}
			} else {
				scrollCount = 0;
			}
			
			lastScrollTime = currentTime;
			window.botDetection.interactions.scroll++;
		}, { passive: true });
	}
	
	// 4. FORM PROTECTION
	
	function protectForms() {
		const forms = document.querySelectorAll('form');
		
		forms.forEach(form => {
			// Skip if already protected
			if (form.dataset.protected === 'true') return;
			
			// Add honeypot fields
			if (config.enableHoneypot) {
				addHoneypotFields(form);
			}
			
			// Track form load time
			const formId = form.id || 'form_' + Math.random().toString(36).substr(2, 9);
			window.botDetection.formLoadTimes.set(formId, Date.now());
			
			// Add submission handler
			form.addEventListener('submit', function(e) {
				if (!validateFormSubmission(e, formId)) {
					e.preventDefault();
					e.stopPropagation();
					
					// Log bot attempt
					logBotAttempt();
					
					// Show error to bot (misleading success)
					if (window.botDetection.isBot) {
						// Fake success to waste bot resources
						setTimeout(() => {
							alert('Thank you! Your message has been sent successfully.');
						}, 1000);
					}
					
					return false;
				}
			});
			
			form.dataset.protected = 'true';
		});
	}
	
	// Add multiple honeypot fields
	function addHoneypotFields(form) {
		const honeypots = [
			{ name: 'email_confirm', type: 'email', label: 'Confirm Email' },
			{ name: 'phone_alt', type: 'tel', label: 'Alternative Phone' },
			{ name: 'website_url', type: 'url', label: 'Website' },
			{ name: 'company_name', type: 'text', label: 'Company' },
			{ name: 'fax_number', type: 'tel', label: 'Fax' }
		];
		
		// Randomly select 2-3 honeypots
		const selectedHoneypots = honeypots.sort(() => 0.5 - Math.random()).slice(0, 2 + Math.floor(Math.random() * 2));
		
		selectedHoneypots.forEach(honeypot => {
			const field = document.createElement('input');
			field.type = honeypot.type;
			field.name = honeypot.name;
			field.className = 'hp-field';
			field.tabIndex = -1;
			field.autocomplete = 'off';
			field.setAttribute('aria-hidden', 'true');
			
			// Multiple hiding techniques
			field.style.cssText = 'position:absolute;left:-9999px;top:-9999px;height:0;width:0;opacity:0;pointer-events:none;';
			
			// Add to form
			form.appendChild(field);
		});
		
		// Add CSS for additional hiding
		if (!document.getElementById('hp-styles')) {
			const style = document.createElement('style');
			style.id = 'hp-styles';
			style.textContent = `
				.hp-field { 
					display: none !important; 
					visibility: hidden !important; 
				}
			`;
			document.head.appendChild(style);
		}
		
		// Add timestamp field
		const timestampField = document.createElement('input');
		timestampField.type = 'hidden';
		timestampField.name = '_timestamp';
		timestampField.value = Date.now();
		form.appendChild(timestampField);
		
		// Add token field for validation
		const tokenField = document.createElement('input');
		tokenField.type = 'hidden';
		tokenField.name = '_token';
		tokenField.value = btoa(window.botDetection.sessionId + ':' + Date.now());
		form.appendChild(tokenField);
	}
	
	// Validate form submission
	function validateFormSubmission(e, formId) {
		const form = e.target;
		let isValid = true;
		const reasons = [];
		
		// Check honeypot fields
		if (config.enableHoneypot) {
			const honeypots = form.querySelectorAll('.hp-field');
			honeypots.forEach(field => {
				if (field.value.trim() !== '') {
					isValid = false;
					reasons.push('honeypot_filled: ' + field.name);
				}
			});
		}
		
		// Check submission time
		if (config.enableTimeValidation) {
			const loadTime = window.botDetection.formLoadTimes.get(formId);
			const submitTime = Date.now();
			const timeDiff = submitTime - loadTime;
			
			if (timeDiff < config.minFormTime) {
				isValid = false;
				reasons.push('form_filled_too_fast: ' + timeDiff + 'ms');
			}
			
			// Also check if form was filled impossibly fast for the amount of fields
			const visibleFields = form.querySelectorAll('input:not([type="hidden"]):not(.hp-field), textarea:not(.hp-field)');
			const minTimePerField = 500; // 500ms minimum per field
			const expectedMinTime = visibleFields.length * minTimePerField;
			
			if (timeDiff < expectedMinTime) {
				isValid = false;
				reasons.push('insufficient_time_per_field');
			}
		}
		
		// Check interaction count
		if (config.enableBehaviorTracking) {
			const totalInteractions = Object.values(window.botDetection.interactions).reduce((a, b) => a + b, 0);
			
			if (totalInteractions < 3) {
				isValid = false;
				reasons.push('no_human_interactions');
			}
			
			// Check for at least mouse or keyboard interaction
			if (window.botDetection.interactions.mouse === 0 && window.botDetection.interactions.keyboard === 0) {
				isValid = false;
				reasons.push('no_input_device_activity');
			}
		}
		
		// Check suspicion score
		if (window.botDetection.suspicionScore >= config.suspiciousBehaviorThreshold) {
			isValid = false;
			reasons.push('high_suspicion_score: ' + window.botDetection.suspicionScore);
		}
		
		// Check for webdriver
		const webdriverSigns = detectWebDriver();
		if (webdriverSigns.length > 0) {
			isValid = false;
			reasons.push('webdriver_detected: ' + webdriverSigns.join(','));
		}
		
		// Update bot detection state
		if (!isValid) {
			window.botDetection.isBot = true;
			window.botDetection.blockedReasons = window.botDetection.blockedReasons.concat(reasons);
		}
		
		return isValid;
	}
	
	// 5. RATE LIMITING
	
	function initRateLimit() {
		// Track requests
		window.addEventListener('submit', function() {
			const now = Date.now();
			window.botDetection.requestCount.push(now);
			
			// Clean old entries (older than 1 minute)
			window.botDetection.requestCount = window.botDetection.requestCount.filter(
				time => now - time < 60000
			);
			
			// Check rate limit
			if (window.botDetection.requestCount.length > config.maxRequestsPerMinute) {
				window.botDetection.isBot = true;
				window.botDetection.blockedReasons.push('rate_limit_exceeded');
			}
		}, true);
	}
	
	// 6. PHONE NUMBER OBFUSCATION
	
	function obfuscatePhoneNumbers() {
		// Find all phone links
		const phoneLinks = document.querySelectorAll('a[href^="tel:"]');
		
		phoneLinks.forEach(link => {
			// Skip if already obfuscated
			if (link.dataset.obfuscated === 'true') return;
			
			const originalNumber = link.href.replace('tel:', '');
			
			// Create obfuscated version
			const parts = originalNumber.split('');
			const obfuscated = parts.map((char, index) => {
				if (index % 2 === 0) {
					return `<span data-char="${btoa(char)}">${String.fromCharCode(char.charCodeAt(0) + 1)}</span>`;
				}
				return `<span>${char}</span>`;
			}).join('');
			
			// Update display
			if (link.textContent.includes(originalNumber)) {
				link.innerHTML = obfuscated;
			}
			
			// Deobfuscate on hover/focus
			link.addEventListener('mouseenter', deobfuscatePhone);
			link.addEventListener('focus', deobfuscatePhone);
			link.addEventListener('mouseleave', reobfuscatePhone);
			link.addEventListener('blur', reobfuscatePhone);
			
			link.dataset.obfuscated = 'true';
			link.dataset.original = originalNumber;
		});
	}
	
	function deobfuscatePhone(e) {
		const link = e.target.closest('a[href^="tel:"]');
		if (link && link.dataset.original) {
			link.textContent = link.dataset.original;
		}
	}
	
	function reobfuscatePhone(e) {
		const link = e.target.closest('a[href^="tel:"]');
		if (link && link.dataset.obfuscated === 'true') {
			// Re-obfuscate after delay
			setTimeout(() => {
				if (!link.matches(':hover') && !link.matches(':focus')) {
					obfuscatePhoneNumbers();
				}
			}, 100);
		}
	}
	
	// 7. LOGGING AND ANALYTICS
	
	function logBotAttempt() {
		// Send to analytics - safely check for gtag
		if (typeof window !== 'undefined' && typeof window.gtag === 'function') {
			try {
				window.gtag('event', 'bot_blocked', {
					'event_category': 'Security',
					'event_label': window.botDetection.blockedReasons.join(', '),
					'value': window.botDetection.suspicionScore,
					'session_id': window.botDetection.sessionId,
					'fingerprint': window.botDetection.fingerprint
				});
			} catch (e) {
				// Ignore gtag errors
				console.debug('Analytics tracking unavailable');
			}
		}
		
		// Console warning for debugging
		console.warn('Bot attempt blocked:', {
			reasons: window.botDetection.blockedReasons,
			score: window.botDetection.suspicionScore,
			sessionId: window.botDetection.sessionId
		});
	}
	
	// 8. CHALLENGE SYSTEM (Invisible by default)
	
	function createChallenge() {
		// Only show challenge if suspicious but not confirmed bot
		if (window.botDetection.suspicionScore > 1 && window.botDetection.suspicionScore < config.suspiciousBehaviorThreshold) {
			// Simple math challenge
			const num1 = Math.floor(Math.random() * 10) + 1;
			const num2 = Math.floor(Math.random() * 10) + 1;
			const answer = num1 + num2;
			
			// Store answer
			sessionStorage.setItem('challenge_answer', btoa(answer.toString()));
			
			// Add challenge to forms
			const forms = document.querySelectorAll('form');
			forms.forEach(form => {
				if (form.querySelector('.challenge-field')) return;
				
				const challengeDiv = document.createElement('div');
				challengeDiv.className = 'challenge-field';
				challengeDiv.innerHTML = `
					<label style="display:block;margin:10px 0;">
						Security Check: What is ${num1} + ${num2}?
						<input type="text" name="_challenge" required style="margin-left:10px;padding:5px;">
					</label>
				`;
				
				// Insert before submit button
				const submitBtn = form.querySelector('[type="submit"]');
				if (submitBtn) {
					submitBtn.parentNode.insertBefore(challengeDiv, submitBtn);
				} else {
					form.appendChild(challengeDiv);
				}
			});
		}
	}
	
	// Validate challenge
	function validateChallenge(form) {
		const challengeField = form.querySelector('[name="_challenge"]');
		if (challengeField) {
			const userAnswer = challengeField.value;
			const correctAnswer = atob(sessionStorage.getItem('challenge_answer') || '');
			
			if (userAnswer !== correctAnswer) {
				window.botDetection.isBot = true;
				window.botDetection.blockedReasons.push('challenge_failed');
				return false;
			}
		}
		return true;
	}
	
	// 9. INITIALIZATION
	
	function initBotProtection() {
		// Generate fingerprint
		generateFingerprint();
		
		// Initialize behavior tracking
		if (config.enableBehaviorTracking) {
			initBehaviorTracking();
		}
		
		// Initialize rate limiting
		if (config.enableRateLimit) {
			initRateLimit();
		}
		
		// Protect forms after DOM is ready
		if (document.readyState === 'loading') {
			document.addEventListener('DOMContentLoaded', () => {
				protectForms();
				obfuscatePhoneNumbers();
				
				// Check if challenge needed
				setTimeout(createChallenge, 2000);
			});
		} else {
			protectForms();
			obfuscatePhoneNumbers();
			setTimeout(createChallenge, 2000);
		}
		
		// Re-protect dynamically added forms
		const observer = new MutationObserver(() => {
			protectForms();
			obfuscatePhoneNumbers();
		});
		
		observer.observe(document.body, {
			childList: true,
			subtree: true
		});
		
		// Detect WebDriver on load
		const webdriverSigns = detectWebDriver();
		if (webdriverSigns.length > 0) {
			window.botDetection.suspicionScore += webdriverSigns.length;
			window.botDetection.blockedReasons = window.botDetection.blockedReasons.concat(webdriverSigns);
		}
	}
	
	// Start protection
	initBotProtection();
	
	// Expose API for manual checks
	window.BotProtection = {
		isBot: () => window.botDetection.isBot,
		getScore: () => window.botDetection.suspicionScore,
		getFingerprint: () => window.botDetection.fingerprint,
		getReasons: () => window.botDetection.blockedReasons,
		checkForm: (formId) => {
			const form = document.getElementById(formId);
			if (form) {
				protectForms();
				return true;
			}
			return false;
		}
	};
	
})();
</script>

<!-- Cloudflare Turnstile Integration -->
<script src="https://challenges.cloudflare.com/turnstile/v0/api.js" async defer></script>